#!/usr/bin/env sh
# vim: set filetype=sh tabstop=2 shiftwidth=2 expandtab :
# shellcheck shell=sh
"${sourced_0d6bf87-false}" && return 0; sourced_0d6bf87=true

set -- "$PWD" "$@"; if test "${2:+$2}" = _LIBDIR; then cd "$3" || exit 1; fi
set -- _LIBDIR .lib "$@"
. ./.lib/utils.lib.sh
shift 2
cd "$1" || exit 1; shift

#MISE description="Generate rounting task tomls for monolithic task definition files."
#MISE tools={"jq"="1.8", "yj"="5"}

main() {
  echo "Updating routing configuration files in project \"$PROJECT_DIR\"." >&2
  cd "$PROJECT_DIR"/mise-tasks || exit 1
  rm -f ./_route-*.toml
  extract_task_info ./*.sh | generate_task_tomls
}

# Parse shell task files and extract task/subcmd information with their metadata.
# Outputs lines in format: "<type> <name> <func_name> <basename> <body>"
extract_task_info() {
  # shellcheck disable=SC2016
  local scr='BEGIN {desc = "";mise_hdrs_count = 0;}/^#MISE / || /^# *\[MISE\] / {line = $0;gsub(/^#MISE +/, "", line);gsub(/^# *\[MISE\] +/, "", line);mise_hdrs[mise_hdrs_count++] = line;next;}/^#/ {if (desc == "") {line = $0;gsub(/^#+[ ]*/, "", line);desc = line;}next;}/^(task_|subcmd_)[[:alnum:]_]()/ {func_name = $1;sub(/\(\).*$/, "", func_name);type = func_name;sub(/_.*$/, "", type);name = func_name;sub(/^[^_]+_/, "", name);gsub(/__/, ":", name);base = FILENAME;sub(/^.*\//, "", base);print type " " name " " func_name " " base " " desc;for (i = 0; i < mise_hdrs_count; i++) {type = "mise";print type " " name " " func_name " " base " " mise_hdrs[i];}desc = "";delete mise_hdrs;mise_hdrs_count = 0;next;}{desc = "";delete mise_hdrs;mise_hdrs_count = 0;}END {print "nop - - - -";}' #EMBED: ./extract-task-info.awk
  awk "$scr" "$@"
}

# Generate the shell script that will be executed when a Mise task is invoked.
# The script changes to the mise-sh directory, sources the library file,
# then returns to the original directory and calls the task function.
gen_script() {
  cat <<EOF
#!/usr/bin/env sh

set -- "\$PWD" "\$@"
cd "\$MISE_TASK_DIR"
. ./"$base"
cd "\$1"
shift
"$1" "\$@"
EOF
}

# Read task info from stdin and generate TOML files for each source file.
# Groups tasks by their source basename and outputs _route-<basename>.toml files.
# Handles "task"/"subcmd" types by setting description and run script,
# and "mise" type by merging additional mise configuration headers.
generate_task_tomls() {
  local task="{}"
  local base_prev=
  local type name func_name base body
  while read -r type name func_name base body
  do
    if test "$base" != "$base_prev"
    then
      if jq -n --argjson input "$task" --exit-status \
        '$input | length > 0' >/dev/null
      then
        if test -r "_route-$base_prev.toml"
        then
          rm -f "_route-$base_prev.toml"
        fi
        {
          echo "# Code generated from \"$base_prev\" by task:route2 task. DO NOT EDIT."
          echo
          printf "%s" "$task" | yj -jt
        } >"_route-$base_prev.toml"
      fi
      task="{}"
    fi
    case "$type" in
      (task|subcmd)
        # Description
        task="$(
          jq -n --argjson input "$task" \
            --arg name "$name" \
            --arg desc "$body" \
            '$input | .[$name]["description"] = $desc'
        )"
        # Function
        task="$(
          jq -n --argjson input "$task" \
            --arg name "$name" \
            --arg script "$(gen_script "$func_name")" \
            '$input | .[$name]["run"] = $script')"
        ;;
      (mise)
        local mise_header="$(printf "%s" "$body" | yj -tj)"
        task="$(
          jq -n --argjson input "$task" \
            --arg name "$name" \
            --argjson mise_header "$mise_header" \
            '$input | .[$name] += $mise_header')"
        ;;
      (nop)
        ;;
      (*)
        exit 1
    esac
    base_prev="$base"
  done
}

set -o nounset -o errexit

main "$@"
