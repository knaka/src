@echo off
setlocal enabledelayedexpansion

if "%~1" == "update-me" (
  curl.exe --fail --location --output %TEMP%\cmd-%~nx0 https://raw.githubusercontent.com/knaka/gobin/main/bootstrap/cmd-gobin.cmd
  move /y %TEMP%\cmd-%~nx0 %~f0
  exit /b 0
)

@REM All releases - The Go Programming Language https://go.dev/dl/
set required_min_major_ver=1
set required_min_minor_ver=23
set ver=!required_min_major_ver!.!required_min_minor_ver!.1

set exit_code=1

:unique_temp_loop
set "temp_dir_path=%TEMP%\%~n0-%RANDOM%"
if exist "!temp_dir_path!" goto unique_temp_loop
mkdir "!temp_dir_path!" || goto :exit
call :to_short_path "!temp_dir_path!"
set temp_dir_spath=!short_path!

set goroot_dir_spath=

call :to_short_path "C:\Program Files"
set program_files_spath=!short_path!
call :to_short_path "%USERPROFILE%"
set user_profile_spath=!short_path!

@REM Command in %PATH%
where go >nul 2>&1 
if !ERRORLEVEL! == 0 (
  for /F "usebackq tokens=*" %%p in (`where go`) do (
    call :to_short_path "%%p"
    set cmd_spath=!short_path!
    call :set_proper_goroot_dir_spath !cmd_spath!
    if !goroot_dir_spath! neq "" (
      goto :found_goroot
    )
  )
)

@REM Trivial installation paths
@REM for /D %%d in (!program_files_spath!\go !user_profile_spath!\sdk\go*) do (
for /D %%d in (!user_profile_spath!\sdk\go*) do (
  set cmd_spath=%%d\bin\go.exe
  if exist !cmd_spath! (
    call :set_proper_goroot_dir_spath !cmd_spath!
    if !goroot_dir_spath! neq "" (
      goto :found_goroot
    )
  )
)

@REM Download if not found
set goos=windows
if "%PROCESSOR_ARCHITECTURE%"=="AMD64" (
  set goarch=amd64
) else if "%PROCESSOR_ARCHITEW6432%"=="AMD64" (
  set goarch=amd64
) else (
  goto :exit
)
set sdk_dir_spath=!user_profile_spath!\sdk
if not exist !sdk_dir_spath! (
  mkdir !sdk_dir_spath! || goto :exit
)
set zip_spath=!temp_dir_spath!\go.zip
echo Downloading Go SDK: !ver! >&2
curl.exe --fail --location -o !zip_spath! "https://go.dev/dl/go!ver!.%goos%-%goarch%.zip" || goto :exit
cd !sdk_dir_spath! || goto :exit
unzip -q !zip_spath! || goto :exit
move /y !sdk_dir_spath!\go !sdk_dir_spath!\go!ver! || goto :exit
set goroot_dir_spath=!sdk_dir_spath!\go!ver!

:found_goroot

set go_cmd_spath=!goroot_dir_spath!\bin\go.exe
set GOROOT=

if not defined GOPATH (
  set GOPATH=!user_profile_spath!\go
)

if not exist !GOPATH!\bin (
  mkdir !GOPATH!\bin
)

set "name=embedded-%~f0"
set "name=!name: =_!"
set "name=!name:\=_!"
set "name=!name::=_!"
set "name=!name:/=_!"
if exist !GOPATH!\bin\!name!.exe (
  xcopy /l /d /y !GOPATH!\bin\!name!.exe "%~f0" | findstr /b /c:"1 " >nul 2>&1
  if !ERRORLEVEL! == 0 (
    goto :execute
  )
)

:build
echo Using Go compiler: !go_cmd_spath! >&2
for /f "usebackq tokens=1 delims=:" %%i in (`findstr /n /b :embed_53c8fd5 "%~f0"`) do set n=%%i
set tempfile=!temp_dir_spath!\!name!.go
more +%n% "%~f0" > !tempfile!

!go_cmd_spath! build -o !GOPATH!\bin\!name!.exe !tempfile! || goto :exit
del /q !temp_dir_spath!

:execute
!GOPATH!\bin\!name!.exe %* || goto :exit
set exit_code=0

:exit
if exist !temp_dir_spath! (
  del /q !temp_dir_spath!
)
exit /b !exit_code!

:to_short_path
set "input_path=%~1"
for %%i in ("%input_path%") do set "short_path=%%~si"
exit /b
goto :eof

:set_proper_goroot_dir_spath
for /F "usebackq tokens=*" %%v in (`%1 env GOVERSION`) do (
  set version=%%v
  set major=!version:~2,1!
  set minor=!version:~4,2!
  if !major! geq !required_min_major_ver! (
  if !minor! geq !required_min_minor_ver! (
    for /F "useback tokens=*" %%p in (`%1 env GOROOT`) do (
      call :to_short_path "%%p"
      set goroot_dir_spath=!short_path!
    )
  )
)
exit /b
goto :eof

endlocal

:embed_53c8fd5
// Code generated by gobin/task-project.lib.sh; DO NOT EDIT.

// Latest version is available by running:
//
//   curl --remote-name https://raw.githubusercontent.com/knaka/gobin/main/bootstrap/cmd-gobin.go

//go:build ignore

package main

import (
	"bufio"
	"crypto/sha1"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

var verbose = false

func v0(err error) {
	if err != nil {
		panic(err)
	}
}

func v[T any](t T, err error) T {
	if err != nil {
		panic(err)
	}
	return t
}

func v2[T any, U any](t T, u U, err error) (T, U) {
	if err != nil {
		panic(err)
	}
	return t, u
}

type paramsT struct {
	initialDirPath string
	global         bool
}

type ConfDirPathOption func(*paramsT) error

// realpath returns the canonical absolute path of the given value.
func realpath(s string) (ret string, err error) {
	ret, err = filepath.Abs(s)
	if err != nil {
		return
	}
	ret, err = filepath.EvalSymlinks(ret)
	if err != nil {
		return
	}
	ret = filepath.Clean(ret)
	return
}

func WithInitialDir(initialDir string) ConfDirPathOption {
	return func(params *paramsT) (err error) {
		params.initialDirPath, err = realpath(initialDir)
		return
	}
}

func WithGlobal(f bool) ConfDirPathOption {
	return func(params *paramsT) error {
		params.global = f
		return nil
	}
}

var mockRootDirPath = ""

// setMockRootDir sets the root directory path for testing.
// Introduced because the temporary directory of Windows is under the user home directory.
func setMockRootDir(dir string) {
	mockRootDirPath = v(realpath(dir))
}

func isRootDir(dir string) bool {
	dirPath, err := realpath(dir)
	if err != nil {
		return false
	}
	if mockRootDirPath != "" {
		return dirPath == mockRootDirPath
	}
	dirPath = filepath.Clean(dirPath)
	return dirPath == filepath.Dir(dirPath)
}

type PkgVerLockMapT map[string]string

const GobinCmdBase = "gobin"
const ManifestFileBase = "Gobinfile"
const ManifestLockFileBase = "Gobinfile-lock"
const goModFileBase = "go.mod"
const GobinDirBase = ".gobin"

func GlobalConfDirPath() (confDirPath string, gobinPath string, err error) {
	confDirPath, err = os.UserHomeDir()
	if err != nil {
		return
	}
	gobinPath = os.Getenv("GOBIN")
	if gobinPath == "" {
		gobinPath = filepath.Join(confDirPath, "go", "bin")
	}
	return
}

func parentDirOf(dir string) string {
	dirPath := v(realpath(dir))
	if mockRootDirPath != "" && mockRootDirPath == dirPath {
		return dir
	}
	return filepath.Dir(dirPath)
}

// ConfDirPath returns the configuration directory path. If the global option is true, it returns the global (home)  configuration directory path. This returns the directory which contains the manifest file. If no manifest file is found in any parent directory, it returns the directory which contains the go.mod file.
func ConfDirPath(opts ...ConfDirPathOption) (
	confDirPath string,
	gobinPath string,
	err error,
) {
	params := &paramsT{}
	for _, opt := range opts {
		err = opt(params)
		if err != nil {
			return
		}
	}
	if params.global {
		return GlobalConfDirPath()
	}
	confDirPath = params.initialDirPath
	if confDirPath == "" {
		confDirPath, err = realpath(".")
		if err != nil {
			return
		}
	}
	goModDirPath := ""
	for {
		// Record the directory which contains the go.mod file.
		if stat, errSub := os.Stat(filepath.Join(confDirPath, goModFileBase)); errSub == nil && !stat.IsDir() {
			if goModDirPath == "" {
				goModDirPath = confDirPath
			}
		}
		// When the manifest file is found, return the directory.
		if stat, err_ := os.Stat(filepath.Join(confDirPath, ManifestFileBase)); err_ == nil && !stat.IsDir() {
			break
		}
		if stat, err_ := os.Stat(filepath.Join(confDirPath, ManifestLockFileBase)); err_ == nil && stat.IsDir() {
			break
		}
		confDirPath = parentDirOf(confDirPath)
		if isRootDir(confDirPath) {
			// If no manifest file is found in any parent directory, return the directory which contains the go.mod file.
			if goModDirPath != "" {
				confDirPath = goModDirPath
				break
			}
			confDirPath, gobinPath, err = "", "", errors.New("no go.mod or manifest file found")
			return
		}
	}
	gobinPath = filepath.Join(confDirPath, GobinDirBase)
	return
}

// GoListOutput represents the output of the `go list` command.
type GoListOutput struct {
	Version string `json:"Version"`
}

// PkgVerLockMap returns the package version lock map.
func PkgVerLockMap(dirPath string) (lockList PkgVerLockMapT, err error) {
	manifestLockPath := filepath.Join(dirPath, ManifestLockFileBase)
	if _, err_ := os.Stat(manifestLockPath); err_ != nil {
		return
	}
	reader := v(os.Open(manifestLockPath))
	scanner := bufio.NewScanner(reader)
	lockList = make(PkgVerLockMapT)
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		divs := strings.SplitN(line, "@", 2)
		lockList[divs[0]] = divs[1]
	}
	return
}

// EnsureInstalled ensures that the program package is installed.
func EnsureInstalled(gobinPath string, pkgPath string, ver string, tags string, log *log.Logger, _ *log.Logger) (cmdPkgVerPath string, err error) {
	pkgBase := path.Base(pkgPath)
	pkgBaseVer := pkgBase + "@" + ver
	cmdPath := filepath.Join(gobinPath, pkgBase+exeExt())
	if tags != "" {
		hash := sha1.New()
		hash.Write([]byte(tags))
		sevenDigits := fmt.Sprintf("%x", hash.Sum(nil))[:7]
		pkgBaseVer += "-" + sevenDigits
	}
	cmdPkgVerPath = filepath.Join(gobinPath, pkgBaseVer+exeExt())
	if _, err_ := os.Stat(cmdPkgVerPath); err_ != nil {
		if verbose {
			log.Printf("Installing %s@%s\n", pkgPath, ver)
		}
		args := []string{"install", fmt.Sprintf("%s@%s", pkgPath, ver)}
		if tags != "" {
			log.Printf("Installing with tags %s\n", tags)
			args = append(args, "-tags", tags)
		}
		cmd := exec.Command(goCmdPath(), args...)
		cmd.Env = append(os.Environ(), fmt.Sprintf("GOBIN=%s", gobinPath))
		cmd.Stdout = os.Stderr
		cmd.Stderr = os.Stderr
		_ = os.Remove(cmdPath)
		v0(cmd.Run())
		_ = os.Remove(cmdPkgVerPath)
		v0(os.Rename(cmdPath, cmdPkgVerPath))
		if pkgBase == GobinCmdBase {
			v0(os.Symlink(pkgBaseVer+exeExt(), cmdPath))
		} else {
			v0(os.Symlink(GobinCmdBase+exeExt(), cmdPath))
		}
	}
	return
}

var Goroot = sync.OnceValues(func() (gobinPath string, err error) {
	// 1.22.7 seems not working on Windows?
	ver := "1.23.1"
	homeDir := v(os.UserHomeDir())
	sdkDirPath := filepath.Join(homeDir, "sdk")
	gorootPath := filepath.Join(sdkDirPath, "go"+ver)
	goCmdPath := filepath.Join(gorootPath, "bin", "go"+exeExt())
	if _, err := os.Stat(goCmdPath); err == nil {
		return gorootPath, nil
	}
	tempDir := v(os.MkdirTemp("", ""))
	defer (func() { v0(os.RemoveAll(tempDir)) })()
	arcPath := filepath.Join(tempDir, "temp.tgz")
	url := fmt.Sprintf("https://go.dev/dl/go%s.%s-%s.tar.gz", ver, runtime.GOOS, runtime.GOARCH)
	//goland:noinspection GoBoolExpressions
	if runtime.GOOS == "windows" {
		arcPath = filepath.Join(tempDir, "temp.zip")
		url = fmt.Sprintf("https://go.dev/dl/go%s.%s-%s.zip", ver, runtime.GOOS, runtime.GOARCH)
	}
	cmd := exec.Command("curl"+exeExt(), "--location", "-o", arcPath, url)
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	v0(cmd.Run())
	cmd = exec.Command("tar"+exeExt(), "-C", sdkDirPath, "-xzf", arcPath)
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	v0(cmd.Run())
	v0(os.Rename(filepath.Join(sdkDirPath, "go"), gorootPath))
	return gorootPath, nil
})

var goCmdPath = sync.OnceValue(func() string {
	binDirPath := filepath.Join(v(Goroot()), "bin")
	v0(os.Setenv("PATH", fmt.Sprintf("%s%c%s", binDirPath, filepath.ListSeparator, os.Getenv("PATH"))))
	cmdPath := filepath.Join(binDirPath, "go"+exeExt())
	if verbose {
		log.Printf("The path to the go command is %s\n", cmdPath)
	}
	return cmdPath
})

func EnsureGobinCmdInstalled(global bool) (cmdPath string, err error) {
	var opts []ConfDirPathOption
	if global {
		opts = append(opts, WithGlobal(true))
	}
	confDirPath, gobinPath := v2(ConfDirPath(opts...))
	pkgVerLockMap := v(PkgVerLockMap(confDirPath))
	modPath := "github.com/knaka/gobin"
	pkgPath := "github.com/knaka/gobin/cmd/gobin"
	ver, ok := pkgVerLockMap[pkgPath]
	if ok {
		if verbose {
			log.Printf("The locked version of %s is %s\n", pkgPath, ver)
		}
	} else {
		if verbose {
			log.Printf("Querying the latest version of %s\n", pkgPath)
		}
		cmd := exec.Command(goCmdPath(), "list", "-m",
			"--json", fmt.Sprintf("%s@%s", modPath, "latest"))
		cmd.Env = append(os.Environ(), "GO111MODULE=on")
		cmd.Stderr = os.Stderr
		output := v(cmd.Output())
		goListOutput := GoListOutput{}
		v0(json.Unmarshal(output, &goListOutput))
		ver = goListOutput.Version
		if verbose {
			log.Printf("The latest version of %s is %s\n", pkgPath, ver)
		}
		manifestLockPath := filepath.Join(confDirPath, ManifestLockFileBase)
		writer := v(os.OpenFile(manifestLockPath, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600))
		defer (func() { v0(writer.Close()) })()
		_ = v(writer.WriteString(fmt.Sprintf("%s@%s\n", pkgPath, ver)))
	}
	return EnsureInstalled(gobinPath, pkgPath, ver, "", log.Default(), log.Default())
}

func Command(name string, arg ...string) (cmd *exec.Cmd, err error) {
	cmd = exec.Command(name, arg...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return
}

func RunCommand(name string, arg ...string) (execErr *exec.ExitError, err error) {
	cmd, err := Command(name, arg...)
	if err != nil {
		return
	}
	err = cmd.Run()
	errors.As(err, &execErr)
	return
}

// bootstrapMain is the main function of the bootstrap command.
func bootstrapMain() {
outer:
	for {
		if len(os.Args) <= 1 {
			break
		}
		switch os.Args[1] {
		case "--verbose":
			verbose = true
		default:
			break outer
		}
		os.Args = append(os.Args[:1], os.Args[2:]...)
	}
	gobinCmdPath := v(EnsureGobinCmdInstalled(false))
	errExec, err := RunCommand(gobinCmdPath, os.Args[1:]...)
	if err == nil {
		os.Exit(0)
	}
	if errExec != nil {
		os.Exit(errExec.ExitCode())
	}
	log.Fatalf("Error 560d8bf: %+v", err)
}

var exeExt = sync.OnceValue(func() (exeExt string) {
	switch runtime.GOOS {
	case "windows":
		exeExt = ".exe"
	}
	return
})

func main() {
	bootstrapMain()
}
